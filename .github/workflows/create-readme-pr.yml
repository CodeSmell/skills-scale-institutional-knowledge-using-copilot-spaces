```yaml
name: Create docs/README PR

on:
  workflow_dispatch:
    inputs:
      target_issue_for_comment:
        description: 'Issue number to post PR link to'
        required: true
        default: '2'
      issue_to_close:
        description: 'Issue number to close after PR creation'
        required: true
        default: '3'
      pr_title:
        description: 'Title for the PR'
        required: true
        default: '[docs] Add docs/README.md — overview & links to OctoAcme process docs'
      pr_body:
        description: 'Body for the PR'
        required: false
        default: 'Adds docs/README.md with a project management process summary and table of contents linking to the docs/ process guides. Links to issue #2.'
      branch_name:
        description: 'Branch name to create'
        required: true
        default: 'docs/add-readme'

jobs:
  create-pr:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Ensure docs directory exists
        run: mkdir -p docs

      - name: Write docs/README.md
        run: |
          cat > docs/README.md <<'EOF'
# OctoAcme Project Management Docs

Welcome! This README provides an overview of how OctoAcme manages projects and quick links to our key process documents. These docs live in the docs/ folder and are intended to centralize project management practices, make them discoverable, and keep them versioned alongside code.

## Project Management Process Summary

OctoAcme leverages a structured, iterative framework for project delivery, focusing on clear roles, transparent communication, and continuous improvement. Our approach includes:

- Customer-focused, incremental delivery — prioritize features that deliver measurable outcomes and iterate based on metrics and feedback.
- Well-defined roles and responsibilities — each project names a Project Manager (PM) and Product Lead (PdM); developers, QA, and stakeholders have clear areas of responsibility.
- Shared artifacts — project one-pagers, risk registers, backlogs, release plans, and sprint-level acceptance criteria.
- Clear lifecycle stages — Initiation, Planning, Execution, Release, Retrospective.
- Frequent communication and transparent reporting — daily standups, weekly delivery syncs, sprint demos, and stakeholder updates.
- Quality-first delivery — CI, automated tests, security scanning, smoke tests, and rollback plans.
- Continuous improvement — capture learnings in retrospectives, track action items, and iterate on the process.

## Process Documents Index

- [Project Management Overview](./octoacme-project-management-overview.md)
- [Project Initiation Guide](./octoacme-project-initiation.md)
- [Project Planning Guide](./octoacme-project-planning.md)
- [Execution & Tracking](./octoacme-execution-and-tracking.md)
- [Risks & Communication](./octoacme-risks-and-communication.md)
- [Release & Deployment Guide](./octoacme-release-and-deployment.md)
- [Retrospective & Continuous Improvement](./octoacme-retrospective-and-continuous-improvement.md)
- [Roles & Personas](./octoacme-roles-and-personas.md)

## Overview of the Process
OctoAcme runs projects through a lightweight, staged lifecycle: initiation (capture problem, stakeholders, one‑pager and success metrics), planning (kickoff, prioritized backlog, estimates, Definition of Done), execution (iterative development and CI-backed reviews), and release/close (deployment checklists, rollbacks, and retrospectives). Key artifacts include a Project One‑pager / charter, a prioritized backlog and release plan, sprint backlogs, a risk register, and acceptance criteria that drive what is considered shippable. The documentation emphasizes iterative delivery and data‑informed decisions as guiding principles for each stage.

Core workflows center on a project board workflow (Backlog → Ready → In Progress → In Review → QA → Done), disciplined PR practices (small PRs, link to issue and acceptance criteria, pass CI/linting, require approvals), and regular planning cadences (sprint planning, daily standups, weekly delivery syncs). Quality assurance is built into the flow: unit and integration tests, end‑to‑end smoke tests for critical flows, security scanning in CI, and manual QA when required. Releases are gated by pre‑release requirements (passing CI/security scans, release notes, rollback plan) and a deployment checklist; a clear rollback and incident playbook is documented for production issues.

Roles and communication are explicit: Product Managers define outcomes and success metrics, Project Managers coordinate delivery, Developers implement and test, QA validates acceptance, and stakeholders receive regular updates. Communication cadence includes daily standups, weekly PM+PdM syncs, twice‑weekly or agreed team standups, and monthly stakeholder updates, with templates for weekly status and incident communication. Risk management and escalation are formalized via a simple risk register and defined escalation paths (team → PM → Product Lead → Sponsor), and continuous improvement is enforced through timeboxed retrospectives that convert learnings into tracked action items.

## How to use these docs

- Update the relevant document when team practices change.
- Link to the appropriate doc from project READMEs or project boards.
- If you add a new process doc, please update this README to include it.
- Keep the Project Charter (one-pager) current in the project repo; use this README as the single source of truth for process links and quick orientation.
EOF

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Create branch and commit changes
        run: |
          git checkout -b "${{ inputs.branch_name }}"
          git add docs/README.md
          git commit -m "docs: add docs/README.md with process summary and index" || echo "No changes to commit"
          git push --set-upstream origin "${{ inputs.branch_name }}"

      - name: Create Pull Request via GitHub API
        id: create_pr
        uses: actions/github-script@v6
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const title = inputs.pr_title;
            const body = inputs.pr_body;
            const head = inputs.branch_name;
            const base = 'main';
            const pr = await github.rest.pulls.create({ owner, repo, title, head, base, body });
            core.setOutput('pr_number', pr.data.number);
            core.setOutput('pr_url', pr.data.html_url);

      - name: Request reviewer @CodeSmell
        uses: actions/github-script@v6
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const pr_number = parseInt(core.getOutput('pr_number'), 10);
            try {
              await github.rest.pulls.requestReviewers({
                owner,
                repo,
                pull_number: pr_number,
                reviewers: ['CodeSmell']
              });
            } catch (err) {
              core.info('Unable to request reviewer: ' + err.message);
            }

      - name: Comment PR link on issue (target)
        uses: actions/github-script@v6
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = parseInt(inputs.target_issue_for_comment, 10);
            const pr_url = core.getOutput('pr_url');
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number,
              body: `Created PR: ${pr_url} — links to this issue for context.`
            });

      - name: Close issue (if requested)
        uses: actions/github-script@v6
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_to_close = parseInt(inputs.issue_to_close, 10);
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: issue_to_close,
              body: `Closing this issue. Implementation is in PR: ${core.getOutput('pr_url')}`
            });
            await github.rest.issues.update({
              owner,
              repo,
              issue_number: issue_to_close,
              state: 'closed'
            });
```
